<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>ViewModel - Tag - Coroutinedispatchers&#39; blog</title>
        <link>coroutinedispatcher.github.io/tags/viewmodel/</link>
        <description>ViewModel - Tag - Coroutinedispatchers&#39; blog</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>stavro96@gmail.com (Stavro Xhardha)</managingEditor>
            <webMaster>stavro96@gmail.com (Stavro Xhardha)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Tue, 27 Aug 2019 10:31:00 &#43;0200</lastBuildDate><atom:link href="coroutinedispatcher.github.io/tags/viewmodel/" rel="self" type="application/rss+xml" /><item>
    <title>How to produce the SavedStateHandle in your ViewModel using AssistedInject</title>
    <link>coroutinedispatcher.github.io/posts/how-to-produce-savedstatehandle-in-your/</link>
    <pubDate>Tue, 27 Aug 2019 10:31:00 &#43;0200</pubDate>
    <author>Author</author>
    <guid>coroutinedispatcher.github.io/posts/how-to-produce-savedstatehandle-in-your/</guid>
    <description><![CDATA[One of my previous article Dagger Multibinding Saved My Time &ldquo;claimed&rdquo; to have found the right practice for providing ViewModels without producing a ViewModel Factory for each ViewModel. Apparently, I was wrong. There are 2 main problems with that approach:
1 - I might forget to add a ViewModel in the Map graph.
2 - With the new SavedStateHandle which stays uniqely in each ViewModel I can&rsquo;t use a generic ViewModel Factory.]]></description>
</item><item>
    <title>Why the ViewModel is now a must</title>
    <link>coroutinedispatcher.github.io/posts/why-viewmodel-is-now-must/</link>
    <pubDate>Tue, 25 Jun 2019 12:53:00 &#43;0200</pubDate>
    <author>Author</author>
    <guid>coroutinedispatcher.github.io/posts/why-viewmodel-is-now-must/</guid>
    <description><![CDATA[Inspired by Lyla Fujiwars latest post, ViewModels with Saved State, Jetpack Navigation, Data Binding and Coroutines, I decided to list some of the reasons why the ViewModel is strongly suggested to be used on the Android app.
1. Views are independent
The ViewModel does fully respect the Single Responsibility Principle, leaving the Activity/Fragmentdo its thing. When the ViewModel is included, views are passive and just wait for changes without actually doing anything.]]></description>
</item></channel>
</rss>
