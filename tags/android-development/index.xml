<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Android Development - Tag - Coroutinedispatchers&#39; blog</title>
        <link>https://coroutinedispatcher.github.io/coroutinedispatcher/tags/android-development/</link>
        <description>Android Development - Tag - Coroutinedispatchers&#39; blog</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>stavro96@gmail.com (Stavro Xhardha)</managingEditor>
            <webMaster>stavro96@gmail.com (Stavro Xhardha)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Sat, 30 May 2020 19:52:00 &#43;0200</lastBuildDate><atom:link href="https://coroutinedispatcher.github.io/coroutinedispatcher/tags/android-development/" rel="self" type="application/rss+xml" /><item>
    <title>Realm 7, the frozen throne</title>
    <link>https://coroutinedispatcher.github.io/coroutinedispatcher/posts/realm-7-frozen-throne/</link>
    <pubDate>Sat, 30 May 2020 19:52:00 &#43;0200</pubDate>
    <author>Author</author>
    <guid>https://coroutinedispatcher.github.io/coroutinedispatcher/posts/realm-7-frozen-throne/</guid>
    <description><![CDATA[onCreate As many of us might know, Realm has already introduced freezing objects. Personally, I have been waiting for long time for such feature. So, what actual problem does this solve?
A lot of us might have faced this issue:
Realm access from incorrect thread. Realm objects can only be accessed on the thread they were created. I believe the error speaks for itself.
Realm &lt; 7.0: When you call Realm.]]></description>
</item><item>
    <title>Why LiveData is the best solution (yet) for UI</title>
    <link>https://coroutinedispatcher.github.io/coroutinedispatcher/posts/why-livedata-is-best-solution-yet-for-ui/</link>
    <pubDate>Sat, 23 May 2020 18:41:00 &#43;0200</pubDate>
    <author>Author</author>
    <guid>https://coroutinedispatcher.github.io/coroutinedispatcher/posts/why-livedata-is-best-solution-yet-for-ui/</guid>
    <description><![CDATA[Why LiveData is the best solution (yet) for UI
As far as I am concerned, there are many developers who don&rsquo;t like LiveData. However, for the UI part, there is no better API to achieve MVVM (or even MVI,or stateful MVVM). Furthermore, makes the UI control very easy.
There might have been some small misconceptions regarding the usage of it, but, if you use LiveData for the purpose it was created, I think that&rsquo;s far better than any other API (for the moment).]]></description>
</item><item>
    <title>Fragments ❤  ViewPager2</title>
    <link>https://coroutinedispatcher.github.io/coroutinedispatcher/posts/fragments-viewpager2/</link>
    <pubDate>Mon, 23 Dec 2019 09:30:00 &#43;0100</pubDate>
    <author>Author</author>
    <guid>https://coroutinedispatcher.github.io/coroutinedispatcher/posts/fragments-viewpager2/</guid>
    <description><![CDATA[The ViewPager2 is a pretty nice rework of the ViewPager API. Some new features you may find with the ViewPager2 are:
1- Vertical scrolling. You can simply enable it by adding: android:orientation=&quot;vertical&rdquo; in the tag in your xml file.
2- Right to left support: you can set the android:layoutDirection=&quot;rtl&rdquo; to enable this.
3- Support for DiffUtil, because it is based on RecyclerView.
4 - Fragments improved support, which we will talk about below.]]></description>
</item><item>
    <title>Some quick notes on Dark Mode</title>
    <link>https://coroutinedispatcher.github.io/coroutinedispatcher/posts/some-quick-notes-on-dark-mode/</link>
    <pubDate>Mon, 09 Sep 2019 10:03:00 &#43;0200</pubDate>
    <author>Author</author>
    <guid>https://coroutinedispatcher.github.io/coroutinedispatcher/posts/some-quick-notes-on-dark-mode/</guid>
    <description><![CDATA[The dark mode, perhaps is one of the easiest functionality to implement without breaking literally anything in existing project. However, it has it&rsquo;s own hidden costs, tricks. Before implementing the Dark mode, what is most important is that your project must be ready for dark mode.
What I had:

What I wanted to achieve:

The setup:
The only thing you need to do to get your app ready for dark mode is the themes tag and the AppCompatDelegate class.]]></description>
</item><item>
    <title>Dagger Multibindings saved my time</title>
    <link>https://coroutinedispatcher.github.io/coroutinedispatcher/posts/dagger-multibindings-saved-my-time/</link>
    <pubDate>Thu, 08 Aug 2019 14:03:00 &#43;0200</pubDate>
    <author>Author</author>
    <guid>https://coroutinedispatcher.github.io/coroutinedispatcher/posts/dagger-multibindings-saved-my-time/</guid>
    <description><![CDATA[While the Android architecture made development simpler, we should always be aware of the Lifecycle and with that, the right way to provide ViewModels. Creating one ViewModel factory for each Fragment and ViewModel you have is really expensive, bad architecture, and too much unnecessary code. Not to mention the fact that you should care about scopes, dependencies, components modules when using Dagger for DI.
You can have a simple &ldquo;generic&rdquo; ViewModel factory for all your app as a Singleton, with the help of Kotlin Reflection and Daggers Multibinding.]]></description>
</item><item>
    <title>Manage network states with the Paging library</title>
    <link>https://coroutinedispatcher.github.io/coroutinedispatcher/posts/manage-network-states-with-paging/</link>
    <pubDate>Wed, 31 Jul 2019 16:22:00 &#43;0200</pubDate>
    <author>Author</author>
    <guid>https://coroutinedispatcher.github.io/coroutinedispatcher/posts/manage-network-states-with-paging/</guid>
    <description><![CDATA[With Room implementation, the Paging Library is not such a big deal. However it needs some small configurations when it comes to using it for API-calls.
One thing to keep in mind, is the initial state, which basically is a different task, which might fail with an Exception. And the same logic is followed by the continues state after the first data are loaded. When using coroutines, we might wanna have an extra problem: managing the CoroutineScope inside a DataSource.]]></description>
</item><item>
    <title>Why the ViewModel is now a must</title>
    <link>https://coroutinedispatcher.github.io/coroutinedispatcher/posts/why-viewmodel-is-now-must/</link>
    <pubDate>Tue, 25 Jun 2019 12:53:00 &#43;0200</pubDate>
    <author>Author</author>
    <guid>https://coroutinedispatcher.github.io/coroutinedispatcher/posts/why-viewmodel-is-now-must/</guid>
    <description><![CDATA[Inspired by Lyla Fujiwars latest post, ViewModels with Saved State, Jetpack Navigation, Data Binding and Coroutines, I decided to list some of the reasons why the ViewModel is strongly suggested to be used on the Android app.
1. Views are independent
The ViewModel does fully respect the Single Responsibility Principle, leaving the Activity/Fragmentdo its thing. When the ViewModel is included, views are passive and just wait for changes without actually doing anything.]]></description>
</item><item>
    <title>What I learned from unit testing</title>
    <link>https://coroutinedispatcher.github.io/coroutinedispatcher/posts/what-i-learned-from-unit-testing/</link>
    <pubDate>Thu, 20 Jun 2019 12:38:00 &#43;0200</pubDate>
    <author>Author</author>
    <guid>https://coroutinedispatcher.github.io/coroutinedispatcher/posts/what-i-learned-from-unit-testing/</guid>
    <description><![CDATA[Testing, testing testing. I was getting inside the &ldquo;Fear of getting behind&rdquo; every time I heard that word. So I decided to react quickly. I knew nothing about testing and this is my experience getting my hands dirty with it. Please feel free to correct anywhere I&rsquo;m wrong. This is a reason why I&rsquo;m writing blogs.
So what the hell is testing?
Testing is just a piece of code where you invoke your written production code and check its&rsquo; behavior.]]></description>
</item></channel>
</rss>
