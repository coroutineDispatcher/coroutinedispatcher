<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Kotlin programming - Tag - Coroutinedispatchers&#39; blog</title>
        <link>http://coroutinedispatcher.com/tags/kotlin-programming/</link>
        <description>Kotlin programming - Tag - Coroutinedispatchers&#39; blog</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>stavro96@gmail.com (Stavro Xhardha)</managingEditor>
            <webMaster>stavro96@gmail.com (Stavro Xhardha)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Sat, 23 May 2020 18:41:00 &#43;0200</lastBuildDate><atom:link href="http://coroutinedispatcher.com/tags/kotlin-programming/" rel="self" type="application/rss+xml" /><item>
    <title>Why LiveData is the best solution (yet) for UI</title>
    <link>http://coroutinedispatcher.com/posts/why-livedata-is-best-solution-yet-for-ui/</link>
    <pubDate>Sat, 23 May 2020 18:41:00 &#43;0200</pubDate>
    <author>Author</author>
    <guid>http://coroutinedispatcher.com/posts/why-livedata-is-best-solution-yet-for-ui/</guid>
    <description><![CDATA[Why LiveData is the best solution (yet) for UI
As far as I am concerned, there are many developers who don&rsquo;t like LiveData. However, for the UI part, there is no better API to achieve MVVM (or even MVI,or stateful MVVM). Furthermore, makes the UI control very easy.
There might have been some small misconceptions regarding the usage of it, but, if you use LiveData for the purpose it was created, I think that&rsquo;s far better than any other API (for the moment).]]></description>
</item><item>
    <title>Coroutines and callbacks</title>
    <link>http://coroutinedispatcher.com/posts/coroutines-and-callbacks/</link>
    <pubDate>Sun, 05 Apr 2020 14:30:00 &#43;0200</pubDate>
    <author>Author</author>
    <guid>http://coroutinedispatcher.com/posts/coroutines-and-callbacks/</guid>
    <description><![CDATA[Callbacks in Java are probably the most basic way to perform executions/send actions between classes. If you have chosen to use coroutines in a project, you want to keep the same style everywhere. But what if some of the libraries you use, are still using callbacks?
No worries, Kotlin coroutines are easily integrated with callbacks. It&rsquo;s just a small workaround to make.
Let&rsquo;s think of a very simple use case:]]></description>
</item><item>
    <title>Let&#39;s get beyond null safety</title>
    <link>http://coroutinedispatcher.com/posts/lets-get-beyond-null-safet/</link>
    <pubDate>Thu, 15 Aug 2019 15:25:00 &#43;0200</pubDate>
    <author>Author</author>
    <guid>http://coroutinedispatcher.com/posts/lets-get-beyond-null-safet/</guid>
    <description><![CDATA[_Inspired by myself and perhaps some other people, who coded Java style in Kotlin. I have seen tones of articles which (mostly) highlight Kotlins null safety and nothing more. So that&rsquo;s it? If it was only for that I swear I would be still using Java with some null checks. Therefore, this article suggest what to use best in Kotlin as well as droping some everyday Java habits.Â _]]></description>
</item></channel>
</rss>
