<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Kotlin - Tag - Coroutinedispatchers&#39; blog</title>
        <link>https://coroutinedispatcher.github.io/coroutinedispatcher/tags/kotlin/</link>
        <description>Kotlin - Tag - Coroutinedispatchers&#39; blog</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>stavro96@gmail.com (Stavro Xhardha)</managingEditor>
            <webMaster>stavro96@gmail.com (Stavro Xhardha)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Sat, 30 May 2020 19:52:00 &#43;0200</lastBuildDate><atom:link href="https://coroutinedispatcher.github.io/coroutinedispatcher/tags/kotlin/" rel="self" type="application/rss+xml" /><item>
    <title>Realm 7, the frozen throne</title>
    <link>https://coroutinedispatcher.github.io/coroutinedispatcher/posts/realm-7-frozen-throne/</link>
    <pubDate>Sat, 30 May 2020 19:52:00 &#43;0200</pubDate>
    <author>Author</author>
    <guid>https://coroutinedispatcher.github.io/coroutinedispatcher/posts/realm-7-frozen-throne/</guid>
    <description><![CDATA[onCreate As many of us might know, Realm has already introduced freezing objects. Personally, I have been waiting for long time for such feature. So, what actual problem does this solve?
A lot of us might have faced this issue:
Realm access from incorrect thread. Realm objects can only be accessed on the thread they were created. I believe the error speaks for itself.
Realm &lt; 7.0: When you call Realm.]]></description>
</item><item>
    <title>Coroutines and callbacks</title>
    <link>https://coroutinedispatcher.github.io/coroutinedispatcher/posts/coroutines-and-callbacks/</link>
    <pubDate>Sun, 05 Apr 2020 14:30:00 &#43;0200</pubDate>
    <author>Author</author>
    <guid>https://coroutinedispatcher.github.io/coroutinedispatcher/posts/coroutines-and-callbacks/</guid>
    <description><![CDATA[Callbacks in Java are probably the most basic way to perform executions/send actions between classes. If you have chosen to use coroutines in a project, you want to keep the same style everywhere. But what if some of the libraries you use, are still using callbacks?
No worries, Kotlin coroutines are easily integrated with callbacks. It&rsquo;s just a small workaround to make.
Let&rsquo;s think of a very simple use case:]]></description>
</item><item>
    <title>Generate Kotlin Docs using Dokka</title>
    <link>https://coroutinedispatcher.github.io/coroutinedispatcher/posts/generate-kotlin-docs-using-dokka/</link>
    <pubDate>Mon, 17 Feb 2020 15:48:00 &#43;0100</pubDate>
    <author>Author</author>
    <guid>https://coroutinedispatcher.github.io/coroutinedispatcher/posts/generate-kotlin-docs-using-dokka/</guid>
    <description><![CDATA[Have you ever generated Kotlin docs (Kdocs) for your library/project? I have. There is a tool for this called Dokka and you can find it here. It&rsquo;s not too hard to set up.
I personally used Dokka for a small API i wrote for SharedPreferences. Anyways, the steps are pretty basic. One thing you must be careful though, is to know the syntax of the Kdocs pretty well (usually, if you know how to generate Javadoc, Kotlin docs don&rsquo;t have much difference).]]></description>
</item><item>
    <title>What I learned from Kotlin Flow API</title>
    <link>https://coroutinedispatcher.github.io/coroutinedispatcher/posts/what-i-learned-from-kotlin-flow-api/</link>
    <pubDate>Fri, 24 Jan 2020 13:54:00 &#43;0100</pubDate>
    <author>Author</author>
    <guid>https://coroutinedispatcher.github.io/coroutinedispatcher/posts/what-i-learned-from-kotlin-flow-api/</guid>
    <description><![CDATA[I used to check the docs and just read a lot about flows but didn&rsquo;t implement anything until yesterday. However, the API tasted really cool (even though some operations are still in Experimental state).
Prerequisites: If you don&rsquo;t know RxJava it&rsquo;s fine. But a RxJava recognizer would read this faster.
Cold vs Hot streams
Well, I really struggled with this concept because it is a little bit tricky. The main difference between cold and hot happened to be pretty simple: Hot streams produce when you don&rsquo;t care while in cold streams, if you don&rsquo;t collect() (or RxJava-s equivalent subscribe()) the stream won&rsquo;t be activated at all.]]></description>
</item><item>
    <title>Searchable Fragments with the Paging Library</title>
    <link>https://coroutinedispatcher.github.io/coroutinedispatcher/posts/searchable-fragments-with-paging-library/</link>
    <pubDate>Mon, 13 Jan 2020 09:00:00 &#43;0100</pubDate>
    <author>Author</author>
    <guid>https://coroutinedispatcher.github.io/coroutinedispatcher/posts/searchable-fragments-with-paging-library/</guid>
    <description><![CDATA[This post is inspired by @EpicPandaForce answer in StackOverflow. I faced the same problem which I didn&rsquo;t know how to solve: How to perform search when you are using a Paging Library (or how the hell to refresh after I reperform Rooms query)?
Let&rsquo;s suppose we have this scenario: I have a list of data, which are shown in the Fragment by LiveData observation, which are retrieved by the ViewModel through LiveDataPagedListBuilder().]]></description>
</item><item>
    <title>Prepopulate Room with data.</title>
    <link>https://coroutinedispatcher.github.io/coroutinedispatcher/posts/prepopulate-room-with-data/</link>
    <pubDate>Mon, 06 Jan 2020 09:04:00 &#43;0100</pubDate>
    <author>Author</author>
    <guid>https://coroutinedispatcher.github.io/coroutinedispatcher/posts/prepopulate-room-with-data/</guid>
    <description><![CDATA[There are times, when we just need the data when the app starts, and all the functionality is just a matter of work. Or we just need the app to be independent from the network and we have the data. A simple dog-race database or cat-race database doesn&rsquo;t actually need online interaction at all (if there are not too many data of course). So, Room comes with a nice solution about this.]]></description>
</item><item>
    <title>Fragments ❤  ViewPager2</title>
    <link>https://coroutinedispatcher.github.io/coroutinedispatcher/posts/fragments-viewpager2/</link>
    <pubDate>Mon, 23 Dec 2019 09:30:00 &#43;0100</pubDate>
    <author>Author</author>
    <guid>https://coroutinedispatcher.github.io/coroutinedispatcher/posts/fragments-viewpager2/</guid>
    <description><![CDATA[The ViewPager2 is a pretty nice rework of the ViewPager API. Some new features you may find with the ViewPager2 are:
1- Vertical scrolling. You can simply enable it by adding: android:orientation=&quot;vertical&rdquo; in the tag in your xml file.
2- Right to left support: you can set the android:layoutDirection=&quot;rtl&rdquo; to enable this.
3- Support for DiffUtil, because it is based on RecyclerView.
4 - Fragments improved support, which we will talk about below.]]></description>
</item><item>
    <title>Setting up Gradle with Kotlin DSL, a simple guide</title>
    <link>https://coroutinedispatcher.github.io/coroutinedispatcher/posts/setting-up-gradle-with-kotlin-dsl/</link>
    <pubDate>Mon, 16 Dec 2019 09:53:00 &#43;0100</pubDate>
    <author>Author</author>
    <guid>https://coroutinedispatcher.github.io/coroutinedispatcher/posts/setting-up-gradle-with-kotlin-dsl/</guid>
    <description><![CDATA[Kotlin is a very a pretty nice adoptive language and user friendly. It really replaced Java from my everyday programming. However, it was not enough. We all know that groovy runs on JVM. So, why do I even need a new language just for my builds? Can&rsquo;t it be Java? So Java is the basic language for the JVM, Kotlin runs on JVM, Groovy runs on JVM and my build system has a separated language from my business logic system.]]></description>
</item><item>
    <title>From Gson to Moshi, what I learned</title>
    <link>https://coroutinedispatcher.github.io/coroutinedispatcher/posts/from-gson-to-moshi-what-i-learned/</link>
    <pubDate>Mon, 28 Oct 2019 10:11:00 &#43;0100</pubDate>
    <author>Author</author>
    <guid>https://coroutinedispatcher.github.io/coroutinedispatcher/posts/from-gson-to-moshi-what-i-learned/</guid>
    <description><![CDATA[There is no doubt that people are getting away from GSON and I agree with those reasons too. The only advantage GSON has over other parsing libraries is that it takes a really short amount of time to set up. Furthermore, the most important thing is that Moshi is embracing Kotlin support.
First let&rsquo;s implement the dependency:
implementation(&#34;com.squareup.moshi:moshi:1.8.0&#34;) It&rsquo;s not a struggle to migrate to Moshi. It&rsquo;s really Gson look-a-like.]]></description>
</item><item>
    <title>Unit testing with coroutines</title>
    <link>https://coroutinedispatcher.github.io/coroutinedispatcher/posts/unit-testing-with-coroutines/</link>
    <pubDate>Mon, 21 Oct 2019 15:19:00 &#43;0200</pubDate>
    <author>Author</author>
    <guid>https://coroutinedispatcher.github.io/coroutinedispatcher/posts/unit-testing-with-coroutines/</guid>
    <description><![CDATA[The coroutines API has already brought some innovation in the Android and Kotlin world. I always loved the idea of keeping it as simple as we all can. There is a saying around here that &ldquo;Whoever talks to much, makes too much mistakes&rdquo; and I see this a little bit related to Java&rsquo;s verbosity and also in the world of concurrency. It&rsquo;s said over and over again that concurrency is not simple and I couldn&rsquo;t agree more: You have to care about context, jobs running in parallel, cancelation, returning values etc.]]></description>
</item></channel>
</rss>
